# 8-1 12:00
完美世界实习  
投递平台：Boss直聘  
投递岗位：  
+ 游戏引擎开发实习生  

# 8-1 12：00 面试回溯
## **C++**
1. 面向对象的特征
> + 封装  
> &emsp;&emsp;将数据和对数据的操作封装成接口的模式，通过接口调用来实现数据操作，以降低代码的耦合性。
> + 继承  
> &emsp;&emsp;子类能够继承父类的方法与实例变量，能够更好的重用父类代码和实现多态。
> + 多态  
> &emsp;&emsp;同一个函数名具有多种状态，即一个接口具有多种不同的行为。
2. 什么是多态，多态的实现
> 多态即同一个函数名具有多种不同的行为，分为编译时多态和运行时多态。
> + 编译时多态，又称静态联编，通过模板和重载来实现。
> + 运行时多态，又称动态联编，通过继承和虚函数来实现。
3. 重载、重写、隐藏的区别
> + 重载：同名函数具有不同的传参列表，根据参数列表来决定调用哪个函数。
> + 重写：子类重写父类的虚函数，重写的函数返回类型、传参列表必须与基类中的同名虚函数相同。
> + 隐藏：子类中的同名函数把父类中的同名函数隐藏掉（覆盖掉）。  
> （重写与隐藏的区别在于父类中的同名函数是否用virtual修饰）
4. 类外函数能否重载
> 当然可以
> ```C++
> #include<iostream>
> using namespace std;
> 
> int addNums(int n1, int n2) {
> 	return n1 + n2;
> }
> 
> int addNums(int n1) {
> 	return n1 * 2;
> }
> 
> int main() {
> 	int n1 = 10;
> 	int n2 = 20;
> 	cout << addNums(n1) << endl;
> 	cout << addNums(n1, n2) << endl;
> }
> ```  
> 打印结果：  
> ![完美世界实习（G）2022-08-05-09-13-43](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-05-09-13-43.png)
5. 虚函数的实现机制
> &emsp;&emsp;虚函数是通过虚函数表来实现的，虚函数表包含了一个类所有的虚函数地址，在有虚函数的类对象中，它内存空间的头部会有一个虚表指针，用来管理虚函数表。当我们用父类指针操作子类对象时，它可以指明实际所调用的函数。
6. 析构函数能否是虚函数，为什么
> &emsp;&emsp;可以且必要，假如基类的析构函数不是虚函数，那么用基类指针或者引用指向派生类时，就只会调用基类的析构函数，一直调用不到派生类对象的析构，从而导致内存泄露。  
> &emsp;&emsp;默认的析构函数为非虚函数是因为虚函数表会占用额外的内存，不会被继承的类采用虚析构函数会导致空间浪费。
7. C++中的模板类是什么，了解多少
> 不太了解，可参考[《C++模板类详解及注意事项》](https://blog.csdn.net/LYXlyxll/article/details/108028024)
8. C++中的内存管理，堆栈的区别
> 内存管理：  
> + 堆：使用malloc、free动态分配和释放空间，能分配较大内存  。
> + 栈：为函数的局部变量分配内存，能分配较小内存。
> + 全局/静态变量存储区：用于存储全局变量和静态变量。
> + 常量存储区：用于存储常量。
> + 自由存储区：通过new、delete分配和释放空间，具体实现可能是堆或者内存池。  
> 
> 堆与栈的区别：
> |  | 堆 | 栈 |
> |:--:|----|----|
> |申请方式|主动申请、释放|自动分配、释放|
> |内存大小|较大（32位机器为4G）|较小（1M）|
> |分配效率|效率低，易产生内存碎片|效率高，但程序无法控制|
> |存放内容|由程序员指定|局部变量、函数参数|
> |物理地址|由低到高，不连续|由高到低，连续|
9. malloc/free和new/delete区别
> |  |malloc/free|new/delete|
> |:--:|--|--|
> |语言区别|C语言的库函数|C++的运算符|
> |功能区别|只进行内存的分配和释放|空间分配释放和类对象的初始化（构造函数、析构函数）|
> |内存大小|需指定内存大小|无需指定内存大小|
> |返回类型|返回void*，再强制转换成所需类型|返回类型指针，类型安全|
> |内存存储|存储在堆中|存储在自由存储区中|
10. 为什么要内存对齐，对其原则
> &emsp;&emsp;计算机从内存中取数据是按照一个固定长度的，如32位机器上CPU每次取出32bit数据，也就是4字节。若不进行内存对齐，要取出两块地址中的数据在进行掩码和移位操作效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度。  
> 
> 对齐原则：
> + 结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除。  
> + 结构体内每一个成员的相对于起始位置的偏移量能够被该变量的大小所整除。
> + 结构体总体大小能过够被最宽成员大小整除。  
> 
> 如何对齐：
> + 声明数据结构时，字节对齐的数据依次声明。
> + 小成员数据组合在一起。
> + 不要把小成员参杂声明在字节对齐的数据之间。
11. C++中类型转换的关键字
> + const_cast  
> &emsp;&emsp;去掉数据成员的const属性，只能作用于指针和引用。  
> + static_cast  
> &emsp;&emsp;隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，也能够进行类层次之间的上下转换（向下转换不安全）。
> + dynamci_cast  
> &emsp;&emsp;动态类型转换，用于基类的指针或引用安全的转换成派生类指针或引用（也可以向上转换）。使用dynamic_cast时基类中必须要有虚函数，否则编译不通过。
> + reinterpret  
> &emsp;&emsp;reinterpret是重新解释的意思，此关键字能够强制转换不同的类型，将数据的二进制形式重新解释，但不改变其值。一般不会使用。
12. 什么是内存泄漏，如何避免
> 由于疏忽或错误导致的程序未能释放已经不再使用的内存。  
> + 使用malloc、calloc、realloc、new等分配内存时，使用完后要调用free或delete释放内存，否则这块内存就会造成内存泄漏。  
> + 指针的重新赋值也会导致初始指向的那块内存无法找到，发生内存泄漏。使用智能指针来避免内存泄露。
13. static的作用以及存储区域
> static作用：  
> + 当static修饰的函数或变量在文件作用域时，表示这些变量或函数只在本文件可见，其他文件看不到也无法使用，可以避免重定义的问题。  
> + 当static修饰的变量在函数作用域时，意味着这个变量只会初始化一次，不会在每次函数调用时进行重置。
> + 当static修饰的变量或函数在类中时，意味着这个变量或函数是所有类共享的一种属性，而非独有的。
> 
> 存储区域：  
> + 局部静态变量在第一次调用函数时分配内存并初始化。
> + 全局变量、文件域的静态变量和类的静态成员变量在main函数执行前的静态初始化过程中分配内存并初始化。
14. 什么是左值和右值，左值引用和右值引用的区别
> **左值**：具有可寻址的存储单元，并且能够由用户改变其值的量，比如常见的变量，左值具有持久的状态，直到离开作用域才销毁。  
> **右值**：即将销毁的临时对象，具有短暂的状态。
15. 内联函数和宏的区别
> inline修饰的内联函数是使编译器在**编译阶段**直接在函数调用点上展开函数，可以避免函数调用的开销，缺点是可能会造成代码膨胀，尤其是递归的函数，会造成大量内存开销。  
> define宏命令是在**预处理阶段**对命令进行替换，适用于简单的函数。
16. lambda表达式
> ![完美世界实习（G）2022-08-06-10-13-33](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-06-10-13-33.png)  
> 
> 参考[C++ Lambda表达式详解](https://blog.csdn.net/qq_37085158/article/details/124626913)  
>```C++
> #include<iostream>
> #include<cmath>
> #include<algorithm>
> using namespace std;
> 
> void abssort(float* x, unsigned n) {
> 	sort(x, x + n,
> 		//lambad expression begin
> 		[](float a, float b) {
> 		return (abs(a) < abs(b));
> 		}
> 		//lambad expression end
> 	);
> }
> 
> int main() {
> 	float x[] = { 1,2,5,8,0,-3,-6,-10 };
> 	abssort(x, 8);
> 	for (int i = 0; i < 8; i++)
> 	{
> 		cout << x[i] << " ";
> 	}
> 	cout << endl;
> }
>```
> ![完美世界实习（G）2022-08-06-10-12-56](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-06-10-12-56.png)
17. 指针和引用的区别
> + 指针本质是一个地址，有自己的内存空间，引用只是一个别名。
> + 指针可以指向其他对象，引用不能指向其他对象，初始化之后就不可改变。
> + 指针可以初始化为nullptr，而引用必须被初始化为一个已有对象的引用。
> + 指针可以是多级指针，而引用只能是一级的  
> 
> 引用的本质是一个指针常量。
18. C++11的新特性
> + auto关键字，可以自动推导出变量的类型。
> + nullptr来代替NULL，可以避免重载的出现问题（一个是int一个是void*）。
> + 智能指针：shared_ptr、unique_ptr、weak_ptr。
> + 右值引用，基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
> + lambda表达式，可以理解为一个匿名的内联函数。
19. 函参传值、传引用、传指针的区别
> + 值传递  
> &emsp;&emsp;在调用一个函数时，会给函数的形参分配空间，并用实参对形参初始化。在函数体中对形参的修改并不能影响到实参，修改的只是实参的副本——形参。
>```C++
> #include<iostream>
> using namespace std;
> 
> void swap(int a, int b) {
> 	int temp = a;
> 	a = b;
> 	b = temp;
> 	cout << "swap::a=" << a << endl;
> 	cout << "swap::b=" << b << endl;
> }
> 
> int main() {
> 	int a = 10, b = 20;
> 	swap(a, b);
> 
> 	cout << "main::a=" << a << endl;
> 	cout << "main::b=" << b << endl;
> }
> ```
> ![完美世界实习（G）2022-08-06-10-43-44](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-06-10-43-44.png)  
> 可以看到值传递时，对形参的修改并不能作用到实参上，操作的只是实参的副本——形参。  
> + 指针传递  
> ```C++
> #include<iostream>
> using namespace std;
> 
> void swap(int* a, int* b) {
> 	int* tmp = a;
> 	a = b;
> 	b = tmp;
> 
> 	cout << "swap::a=" << *a << endl;
> 	cout << "swap::b=" << *b << endl;
> }
> 
> int main() {
> 	int a = 10, b = 20;
> 	swap(&a, &b);
> 
> 	cout << "main::a=" << a << endl;
> 	cout << "main::b=" << b << endl;
> }
> ```  
> ![完美世界实习（G）2022-08-06-10-55-47](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-06-10-55-47.png)  
> &emsp;&emsp;可以看到，虽然swap函数中交换了a和b的地址，但是实际交换的时交换了swap函数中指针变量a和指针变量b所存储的地址，对main函数中的a和b没有任何影响。要修改main函数中的a和b，就需要对指针a和指针b所存储的地址进行修改。
> + 引用传递
> ```C++
> #include<iostream>
> using namespace std;
> 
> void swap(int& a, int& b) {
> 	int temp = a;
> 	a = b;
> 	b = temp;
> 
> 	cout << "swap::a=" << a << endl;
> 	cout << "swap::b=" << b << endl;
> }
> 
> int main() {
> 	int a = 10, b = 20;
> 	swap(a, b);
> 
> 	cout << "main::a=" << a << endl;
> 	cout << "main::b=" << b << endl;
> }
> ```
> ![完美世界实习（G）2022-08-06-11-44-09](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-06-11-44-09.png)  
> 在传参数时进行引用传递，就相当于给实参起了个别名，这个别名就是形参，对形参的操作会作用到实参上。
20. 什么是纯虚函数
> 纯虚函数是指被标明为不具体实现的虚拟成员函数。通常情况下，纯虚函数常用在以下情况：  
> &emsp;&emsp;**定义一个基类时，基类中虚函数的具体实现由于必须依赖派生类的具体情况从而无法在基类中确切定义，此时可以把这个虚函数定义为虚函数**。纯虚函数的语法为：
> 
> ```C++
> virtual void func() = 0;
> ```

## **操作系统**
1. 动态链接和静态链接的区别
> + 动态链接  
> &emsp;&emsp;动态链接是程序运行时动态装入内存的模块，格式为.dll文件，在程序运行时是可以随意加载和移除的，节省内存空间
> + 静态链接  
> &emsp;&emsp;静态链接一般在工程的设置界面加入工程中，格式为.lib文件，程序编译时会把.lib文件代码加入到程序中，因此会增加代码大小。不能手动移除.lib代码。
2. 用户态和内核态，如何切换
> &emsp;&emsp;运行在用户态下的程序只能**受限的访问内存**，不允许访问外围设备，占用CPU的能力被剥夺，CPU资源可以被其他程序获取。  
> &emsp;&emsp;运行在内核态下的程序可以**访问内存所有数据**，包括外围设备。  
> 
> 用户态切换到内核态的三种方式：  
> - 系统调用：用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用，申请使用操作系统提供的服务程序以完成工作。
> - 异常：当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理此异常的内核相关程序中，因此也就转到了内核态，比如缺页异常。
> - 外围设备终端：外围设备完成用户请求的操作后，会向CPU发送相应的中断信号，此时CPU会暂停执行下一条即将要执行的命令，转而执行与中断信号对应的处理程序，因此转到了内核态。
3. 操作系统如何管理内存，什么是虚拟内存
> &emsp;&emsp;操作系统通过一种分页管理机制来进行内存管理。分页机制将程序的逻辑地址划分为固定大小的页，将物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一帧，这些帧不必连续，从而实现了离散分离。  
> &emsp;&emsp;虚拟内存是基于分页存储管理机制的，它允许程序不必将所有的页都放入内存中，而是只将一部分页映射到内存中，另一部分页放在外存上（如磁盘、软盘、USB），当引用到不存在内存中的页时，系统产生缺页中断，并从外存设备中调入该部分页进来，从而产生一种逻辑上内存得到扩充的感觉，实际上内存并没有增加。
4. 云服务器的分配原理
5. 进程同步机制
6. 线程同步机制
7. 页面置换算法

## **计算机网络**
1. 网页请求的过程
> &emsp;&emsp;当用户请求网页时，浏览器得到了一个域名。而在实际的通信过程中，我们需要的是一个具体的IP地址。因此我们需要先把域名转化成相应的IP地址，这个过程称作DNS解析。根据IP找到IP对应的服务器。  
> - 浏览器首先搜索浏览器自身缓存的DNS记录。
> - 如果浏览器缓存中没有找到需要的记录或记录已经过期，则搜索hosts文件和操作系统缓存。
> - 如果在hosts文件和操作系统缓存中没有找到需要的记录或记录已过期，则向域名解析服务器发送解析请求
> - 如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析。
> - 获取域名对应的IP后，一步步向上返回，知道返回给浏览器。  
> 
> 详见[《一次完整的网页请求过程》](https://blog.csdn.net/weixin_43485035/article/details/116600527)

## **引擎相关**
1. 模型导入场景的过程中经历了什么

# 8-3 13：00 二面回溯
没想到一面能过。。。但是二面铁G了。  
1. 常用的排序算法
> 简单选择、插入排序、冒泡排序、快排、堆排序、shell排序、归并排序
2. 冒泡算法原理
> 从前往后两两比较，逆序则交换，不断重复直到有序为止，时间复杂度平均O(n<sup>2</sup>) ，最好情况O(n)，即序列本身有序。
3. 快排原理，时间复杂度
> 每轮选择一个基准值，小于基准值的放左边，大于基准值的放右边，递归对左子序列和右子序列进行划分。时间复杂度平均O(nlogn)，最坏情况O(n<sup>2</sup>)。
4. 为什么最坏是n<sup>2</sup>
5. 为什么最好是nlogn，如何计算
6. 析构函数的作用
> 将不再使用的对象释放，避免内存泄漏。
7. 为什么析构函数可以是虚函数，有什么好处
> &emsp;&emsp;如果析构函数不是虚函数，那么用基类指针或引用指向派生类时，就只会调用基类的析构函数，一直调用不到派生类对象的析构，从而导致内存泄露。  
> &emsp;&emsp;默认的析构函数不是虚函数是因为虚函数表会占用额外的内存，不会被继承的类采用虚析构函数会导致空间浪费。