# 8-1 12:00
完美世界实习  
投递平台：Boss直聘  
投递岗位：  
+ 游戏引擎开发实习生  

# 8-1 12：00 面试回溯
## **C++**
1. 面向对象的特征
> + 封装  
> &emsp;&emsp;将数据和对数据的操作封装成接口的模式，通过接口调用来实现数据操作，以降低代码的耦合性。
> + 继承  
> &emsp;&emsp;子类能够继承父类的方法与实例变量，能够更好的重用父类代码和实现多态。
> + 多态  
> &emsp;&emsp;同一个函数名具有多种状态，即一个接口具有多种不同的行为。
2. 什么是多态，多态的实现
> 多态即同一个函数名具有多种不同的行为，分为编译时多态和运行时多态。
> + 编译时多态，又称静态联编，通过模板和重载来实现。
> + 运行时多态，又称动态联编，通过继承和虚函数来实现。
3. 重载、重写、隐藏的区别
> + 重载：同名函数具有不同的传参列表，根据参数列表来决定调用哪个函数。
> + 重写：子类重写父类的虚函数，重写的函数返回类型、传参列表必须与基类中的同名虚函数相同。
> + 隐藏：子类中的同名函数把父类中的同名函数隐藏掉（覆盖掉）。  
> （重写与隐藏的区别在于父类中的同名函数是否用virtual修饰）
4. 类外函数能否重载
> 当然可以
> ```C++
> #include<iostream>
> using namespace std;
> 
> int addNums(int n1, int n2) {
> 	return n1 + n2;
> }
> 
> int addNums(int n1) {
> 	return n1 * 2;
> }
> 
> int main() {
> 	int n1 = 10;
> 	int n2 = 20;
> 	cout << addNums(n1) << endl;
> 	cout << addNums(n1, n2) << endl;
> }
> ```  
> 打印结果：  
> ![完美世界实习（G）2022-08-05-09-13-43](https://raw.githubusercontent.com/ZZh2333/picgoResource/main/img/%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E5%AE%9E%E4%B9%A0%EF%BC%88G%EF%BC%892022-08-05-09-13-43.png)
5. 虚函数的实现机制
> &emsp;&emsp;虚函数是通过虚函数表来实现的，虚函数表包含了一个类所有的虚函数地址，在有虚函数的类对象中，它内存空间的头部会有一个虚表指针，用来管理虚函数表。当我们用父类指针操作子类对象时，它可以指明实际所调用的函数。
6. 析构函数能否是虚函数，为什么
> &emsp;&emsp;可以且必要，假如基类的析构函数不是虚函数，那么用基类指针或者引用指向派生类时，就只会调用基类的析构函数，一直调用不到派生类对象的析构，从而导致内存泄露。  
> &emsp;&emsp;默认的析构函数为非虚函数是因为虚函数表会占用额外的内存，不会被继承的类采用虚析构函数会导致空间浪费。
7. C++中的模板类是什么，了解多少
> 不太了解，可参考[C++模板类详解及注意事项](https://blog.csdn.net/LYXlyxll/article/details/108028024)
8. C++中的内存管理，堆栈的区别
> 内存管理：  
> + 堆：使用malloc、free动态分配和释放空间，能分配较大内存  。
> + 栈：为函数的局部变量分配内存，能分配较小内存。
> + 全局/静态变量存储区：用于存储全局变量和静态变量。
> + 常量存储区：用于存储常量。
> + 自由存储区：通过new、delete分配和释放空间，具体实现可能是堆或者内存池。  
> 
> 堆与栈的区别：
> |  | 堆 | 栈 |
> |:--:|----|----|
> |申请方式|主动申请、释放|自动分配、释放|
> |内存大小|较大（32位机器为4G）|较小（1M）|
> |分配效率|效率低，易产生内存碎片|效率高，但程序无法控制|
> |存放内容|由程序员指定|局部变量、函数参数|
> |物理地址|由低到高，不连续|由高到低，连续|
9.  malloc/free和new/delete区别
> |  |malloc/free|new/delete|
> |:--:|--|--|
> |语言区别|C语言的库函数|C++的运算符|
> |功能区别|只进行内存的分配和释放|空间分配释放和类对象的初始化（构造函数、析构函数）|
> |内存大小|需指定内存大小|无需指定内存大小|
> |返回类型|返回void*，再强制转换成所需类型|返回类型指针，类型安全|
> |内存存储|存储在堆中|存储在自由存储区中|
10. 为什么要内存对齐，对其原则
> &emsp;&emsp;计算机从内存中取数据是按照一个固定长度的，如32位机器上CPU每次取出32bit数据，也就是4字节。若不进行内存对齐，要取出两块地址中的数据在进行掩码和移位操作效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度。  
> 
> 对齐原则：
> + 结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除。  
> + 结构体内每一个成员的相对于起始位置的偏移量能够被该变量的大小所整除。
> + 结构体总体大小能过够被最宽成员大小整除。  
> 
> 如何对齐：
> + 声明数据结构时，字节对齐的数据依次声明。
> + 小成员数据组合在一起。
> + 不要把小成员参杂声明在字节对齐的数据之间。
11.  C++中类型转换的关键字
> + const_cast  
> &emsp;&emsp;去掉数据成员的const属性，只能作用于指针和引用。  
> + static_cast  
> &emsp;&emsp;隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，也能够进行类层次之间的上下转换（向下转换不安全）。
> + dynamci_cast  
> &emsp;&emsp;动态类型转换，用于基类的指针或引用安全的转换成派生类指针或引用（也可以向上转换）。使用dynamic_cast时基类中必须要有虚函数，否则编译不通过。
> + reinterpret  
> &emsp;&emsp;reinterpret是重新解释的意思，此关键字能够强制转换不同的类型，将数据的二进制形式重新解释，但不改变其值。一般不会使用。
12.  什么是内存泄露，如何避免
> 由于疏忽或错误导致的程序未能释放已经不再使用的内存。  
> + 使用malloc、calloc、realloc、new等分配内存时，使用完后要调用free或delete释放内存，否则这块内存就会造成内存泄露。  
> + 指针的重新赋值也会导致初始指向的那块内存无法找到，发生内存泄露。
13.  static的作用以及存储区域
> static作用：  
> + 当static修饰的函数或变量在文件作用域时，表示这些变量或函数只在本文件可见，其他文件看不到也无法使用，可以避免重定义的问题。  
> + 当static修饰的变量在函数作用域时，意味着这个变量只会初始化一次，不会在每次函数调用时进行重置。
> + 当static修饰的变量或函数在类中时，意味着这个变量或函数是所有类共享的一种属性，而非独有的。
> 
> 存储区域：  
> + 局部静态变量在第一次调用函数时分配内存并初始化。
> + 全局静态变量
1.   什么是左值和右值，左值引用和右值引用的区别
2.   内联函数和宏的区别
3.   lambda表达式
4.   指针和引用的区别
5.   C++11的新特性
6.   函参传值、传引用、传指针的区别
7.  什么是纯虚函数

## **操作系统**
1. 动态链接和静态链接的区别
2. 用户态和内核态，如何切换
3. 操作系统如何管理内存，什么是虚拟内存
4. 云服务器的分配原理
5. 进程同步机制
6. 线程同步机制
7. 页面置换算法

## **计算机网络**
1. 网页请求的过程

## **引擎相关**
1. 模型导入场景的过程中经历了什么

# 8-3 13：00 二面回溯
没想到一面能过。。。但是二面铁G了。  
1. 常用的排序算法
2. 冒泡算法原理
3. 快排原理，时间复杂度
4. 为什么最坏是n<sup>2<sup>
5. 为什么最好是nlogn，如何计算
6. 析构函数的作用
7. 为什么析构函数可以是虚函数，有什么好处